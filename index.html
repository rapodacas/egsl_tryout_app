<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Softball Tryout App</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
  body {
    margin: 0;
    padding: 0;
    background: #f2f2f7;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    overflow-x: hidden;
    /* font-size: 40px; */
  }
  input, textarea, label, .player-name, .section-title { font-size: 3.0rem; }

  /* Start Screen */
  #teamSelectScreen {
    padding: 20px 16px;
  }

  #teamSelectScreen h1 {
    font-size: 1.4rem;
    margin-bottom: 12px;
  }

  .team-list {
    margin-top: 10px;
    margin-bottom: 16px;
  }

  .team-item {
    padding: 10px 12px;
    border-radius: 10px;
    background: #fff;
    margin-bottom: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .team-item span {
    font-size: 0.95rem;
    font-weight: 600;
  }

  .team-empty {
    font-size: 0.9rem;
    color: #777;
    font-style: italic;
  }

  .team-actions {
    margin-top: 10px;
  }

  .team-actions input {
    width: 100%;
    padding: 8px;
    border-radius: 10px;
    border: 1px solid #ccc;
    font-size: 0.9rem;
    margin-bottom: 8px;
  }

  .team-actions button {
    width: 100%;
    padding: 8px;
    border-radius: 10px;
    border: none;
    background: #007aff;
    color: #fff;
    font-size: 0.9rem;
  }

  /* Top Bar */
  .top-bar {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 10px 12px;
    background: #fff;
    border-bottom: 1px solid #ddd;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .top-row {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .player-name {
    font-size: 2.0rem;
    font-weight: 700;
  }

  .player-controls {
    text-align:center;
  }
  .player-controls button {
    padding: 6px 6px;
    border-radius: 8px;
    border: none;
    background: #007aff;
    color: white;
    font-size: 1.7rem;
    margin-left: 4px;
  }

  /* Summary Bar */
  .summary-bar-container {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .summary-progress-outer {
    width: 100%;
    height: 8px;
    border-radius: 999px;
    background: #e0e0e0;
    overflow: hidden;
  }

  .summary-progress-inner {
    height: 100%;
    width: 0%;
    border-radius: 999px;
    background: #34c759;
    transition: width 0.2s ease-out;
  }

  .summary-text {
    font-size: 1rem;
    color: #555;
    display: flex;
    justify-content: space-between;
  }

  /* Card */
  .card {
    background: white;
    margin: 6px;
    padding: 8px;
    border-radius: 14px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }

  .field {
    margin-bottom: 10px;
    padding: 8px;
    border-radius: 10px;
    border: 1px solid #ddd;
    background: #fafafa;
  }

  label {
    font-size: 1rem;
    font-weight: 600;
    display: block;
    margin-bottom: 4px;
  }

  input, textarea {
    width: 100%;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid #ccc;
    font-size: 1.1rem;
    box-sizing: border-box;
    background: #fff;
  }

  textarea {
    min-height: 60px;
  }


  /* Profile Photo */
  .profile-row {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    margin-bottom: 12px;
  }

  .profile-pic-wrapper {
    width: 145px;
    height: 145px;
    border-radius: 50%;
    overflow: hidden;
    border: 2px solid #ccc;
    background: #eaeaea;
    flex-shrink: 0; /* prevents distortion */
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
  }

  .profile-pic-wrapper img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* keeps aspect ratio while filling the circle */
  }

  #photoInput {
    display: none;
  }

  /* Throws/Bats pill buttons */
  .throws-group {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }

  .throws-option {
    flex: 1;
    text-align: center;
    padding: 6px 4px;
    border-radius: 999px;
    border: 1px solid #ccc;
    font-size: 0.8rem;
    background: #fff;
    cursor: pointer;
    user-select: none;
  }

  .throws-option.selected {
    background: #007aff;
    color: #fff;
    border-color: #007aff;
  }

  /* All Players View */
  #allPlayersView {
    display: none;
    padding: 12px;
  }

  .players-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
  }

  .players-table th,
  .players-table td {
    padding: 8px;
    border-bottom: 1px solid #ddd;
  }

  .players-table tr {
    cursor: pointer;
  }

  .players-table tr:hover {
    background: #f0f0f0;
  }
    /* Center all table content */ 
  .players-table th, .players-table td { 
    text-align: center; 
    }
  /* Alternating row colors */ 
  .players-table tbody tr:nth-child(odd) { background: #fafafa; } 
  .players-table tbody tr:nth-child(even) { background: #ffffff; }
  /* Sortable column cursor */ .players-table th { cursor: pointer; user-select: none; }
  /* Highlight sorted column */ .players-table th.sorted-asc::after { content: " ‚ñ≤"; font-size: 0.7rem; } 
  .players-table th.sorted-desc::after { content: " ‚ñº"; font-size: 0.7rem; }
  /* Left-align only the Player column */
  .players-table td:first-child, .players-table th:first-child {
      text-align: left; padding-left: 8px; 
      /* optional: adds breathing room */ 
  }

  /* PLAYER NAVIGATION BAR */
  #playerNavBar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #ffffff;
    padding: 8px 12px;
    border-bottom: 1px solid #d0d0d5;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  }

  #playerNavBar .nav-arrow {
    background: #f2f2f7;
    border: 1px solid #c8c8cc;
    border-radius: 6px;
    padding: 6px 12px;
    font-size: 20px;
    cursor: pointer;
    min-width: 40px;
    transition: background 0.15s ease;
  }

  #playerNavBar .nav-arrow:active {
    background: #e0e0e5;
  }

  #playerNavBar .nav-arrow:disabled {
    opacity: 0.35;
    cursor: default;
  }

  #navPlayerTitle {
    flex: 1;
    text-align: center;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
  }

  #navPlayerTitle:active {
    opacity: 0.6;
  }

  /* CATEGORY CARD WRAPPER */
  .category-card {
    background: #ffffff;
    border: 1px solid #d0d0d5;
    border-radius: 10px;
    padding: 6px;
    margin-bottom: 10px;
  }
  
  /* CATEGORY TITLE */
  .section-title {
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 6px;
  }
  
  /* SWIPABLE PANEL */
  .progress-panel {
    background: #fafafa;
    border: 1px solid #d0d0d5;
    border-radius: 8px;
    padding: 12px;
    user-select: none;
    transition: transform 0.15s ease;
  }
  
  /* SWIPE ANIMATION STATES */
  .progress-panel.swipe-left {
    transform: translateX(-20px);
  }
  .progress-panel.swipe-right {
    transform: translateX(20px);
  }
  /* UNIFIED RECORD UI */
  .progress-record {
    display: flex;
    flex-direction: column;
    gap: 14px; 
  }
  /* RATING GRID (CIRCLES) */
  .rating-group-grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 8px;
  }
  .rating-item {
    display: flex;
    flex-direction: column;
  }
  .rating-label {
    font-size: 13px;
    margin-bottom: 4px;
    color: #444;
  }
  /* CIRCLE UI */
  .rating-circles {
    display: flex;
    gap: 6px;
  }

  .circle {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 1px solid #aaa;
    background: #eaeaea;
    transition: background 0.15s ease, border-color 0.15s ease;
  }

  .circle.active-blue {
    background-color: #007bff;
    border-color: #007bff;
  }

  .circle.active-green {
    background-color: #28a745;
    border-color: #28a745;
  }

  /* PROGRESS META */
  .progress-meta { 
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    color: #555;
    padding-top: 4px;
    border-top: 1px solid #ddd; 
  }
  
  .progress-body {
    display: flex;
    flex-direction: column-reverse;
  }

  .attachments-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    opacity: 0.75;
    transition: opacity 0.15s ease;
  }

  .attachments-indicator:hover {
    opacity: 1;
  }

  .attachments-icon {
    width: 16px;
    height: 16px;
  }

  .attachments-count {
    font-size: 12px;
    color: #444;
  }

  .attachments-indicator.disabled {
    opacity: 0.3;
    pointer-events: none;
  }

  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999;
  }

  .modal.hidden {
    display: none;
  }

  .modal-content {
    background: white;
    padding: 16px;
    border-radius: 8px;
    max-width: 420px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
  }

  .attachment-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, 90px);
    gap: 8px;
  }

  .attachment-thumb {
    width: 90px;
    height: 90px;
    overflow: hidden;
    border-radius: 6px;
    background: #eee;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .thumb-img, .thumb-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .attachment-viewer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.75);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  .attachment-viewer-content {
    background: #fff;
    width: 90%;
    max-width: 480px;
    max-height: 90%;
    overflow-y: auto;
    border-radius: 12px;
    padding: 16px;
  }

  .attachment-viewer-content img,
  .attachment-viewer-content video {
    width: 100%;
    border-radius: 8px;
    margin-bottom: 12px;
  }

  .attachment-viewer-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: 12px;
  }

  .attachment-viewer-buttons button {
    padding: 8px 14px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
  }

  /* Base badge */
  .eval-session-badge {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-left: 6px;
  }

  /* No evaluations yet */
  .eval-none {
    background-color: #9ca3af; /* neutral gray */
  }

  /* Some evaluated OR partial failures */
  .eval-some {
    background-color: #fbbf24; /* amber/yellow */
  }

  /* All evaluated successfully */
  .eval-all {
    background-color: #10b981; /* green */
  }

  .eval-session-badge:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    background: #111;
    color: #fff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    white-space: nowrap;
    transform: translateY(-22px);
    pointer-events: none;
  }

  .upload-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.4);
    color: white;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
  }

  .hidden {
    display: none !important;
  }

  .upload-overlay-content {
    text-align: center;
  }

  /* Spinner */
  .spinner {
    width: 32px;
    height: 32px;
    border: 4px solid rgba(255,255,255,0.3);
    border-top-color: white;
    border-radius: 50%;
    margin: 0 auto 12px auto;
    animation: spin 0.9s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Progress bar (you already have this) */
  .upload-bar {
    width: 200px;
    height: 6px;
    background: rgba(255,255,255,0.3);
    margin-top: 12px;
    border-radius: 3px;
    overflow: hidden;
  }

  #uploadBarFill {
    width: 0%;
    height: 100%;
    background: white;
    transition: width 0.1s linear;
  }

  .invisible-file-input {
    position: absolute;
    width: 1px;
    height: 1px;
    opacity: 0;
    overflow: hidden;
  }

</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

</head>
<body>

<!-- TEAM SELECTION SCREEN -->
<div id="teamSelectScreen">
  <h1>Select or create a team</h1>
  <div id="teamList" class="team-list"></div>

  <div class="team-actions">
    <input type="text" id="newTeamName" placeholder="New team name (e.g., 12U A)">
    <button onclick="createTeam()">Create New Team</button>
  </div>
  <div class="team-actions">
    <button onclick="triggerCSVImport()">Import Team CSV</button>
    <input type="file" id="teamCSVInput" accept=".csv" style="display:none">
  </div>
</div>

<!-- MAIN APP -->
<div id="mainApp" class="hidden">

  <!-- TOP BAR -->
  <div class="top-bar">
    <div class="top-row">
      <div class="player-controls">
        <button onclick="toggleAllPlayers()">All Players</button>
        <!-- <button onclick="addPlayer()">+</button>
        <button onclick="deletePlayer()" style="font-size: 1.5rem;">üóë</button>
        <button onclick="exportCSV()">CSV</button>
        <button onclick="exportPDF()">PDF</button> -->
        <button onclick="toggleTeamSummary()">Summary</button>
      </div>
    </div>
  </div>

  <!-- ALL PLAYERS VIEW -->
  <div id="allPlayersView">
    <h2>All Players</h2>
    <table class="players-table" id="playersTable">
      <thead>
        <tr>
          <th>#</th>
          <th>Name</th>
          <th>ü¶Øüí•</th>
          <th>ü•é</th>
          <th>üèÉ</th>
          <th>Overall</th>
          <th>%</th>
        </tr>
      </thead>
      <tbody id="playersTableBody"></tbody>
    </table>
  </div>

  <!-- TEAM SUMMARY VIEW -->
  <div id="teamSummaryView" style="display:none; padding: 12px;">
    <h2>Team Summary</h2>
    <table class="players-table" id="teamSummaryTable">
      <thead>
        <tr>
          <th>Category</th>
          <th>Average</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- PLAYER CARD -->
  <div class="swipe-container" id="swipeArea">
    <div class="card" id="playerCard">
      <!-- PLAYER NAVIGATION BAR -->
      <div id="playerNavBar">
        <button class="nav-arrow" id="navPrevPlayer">‚Äπ</button>
        <div id="navPlayerTitle">
          <span id="navPlayerText">Player 1 of 1</span>
        </div>
        <button class="nav-arrow" id="navNextPlayer">‚Ä∫</button>
      </div>

      <div class="player-name" id="playerNameDisplay">Player 1</div>

      <div class="summary-bar-container">
        <div class="summary-progress-outer">
          <div class="summary-progress-inner" id="summaryProgress"></div>
        </div>
        <div class="summary-text">
          <span id="summaryScore">Score: 0</span>
          <span id="summaryAvg">Avg: 0.0</span>
          <span id="summaryCompletion">0%</span>
        </div>
      </div>

      <!-- PROFILE + NAME + THROWS -->
      <div class="profile-row">
        <!-- Profile Photo -->
        <div class="profile-pic-wrapper" id="profilePicWrapper">
          <img id="profilePic" src="" alt="">
        </div>
        <input type="file" id="photoInput" accept="video/*" capture="camera">

        <!-- Name + Throws -->
        <div>
          <div class="field">
            <label>Name</label>
            <input type="text" data-field="name">
          </div>

          <div class="field">
            <label>Throws/Bats</label>
            <div class="throws-group" id="throwsGroup">
              <div class="throws-option" data-throws-value="R/R">R/R</div>
              <div class="throws-option" data-throws-value="R/L">R/L</div>
              <div class="throws-option" data-throws-value="L/R">L/R</div>
              <div class="throws-option" data-throws-value="L/L">L/L</div>
            </div>
          </div>
        </div>
      </div>

      <div class="field">
        <textarea data-field="notes" placeholder="Strengths, weaknesses, recommended positions..."></textarea>
      </div>

      <!-- RATINGS -->
      <div class="category-card" id="card-hitting">
        <div class="section-title">Hitting</div>
        <div class="progress-panel swipe-zone" id="progress-hitting">
          <div class="progress-record" id="hittingRecord">
            <div class="rating-group-grid"></div>
            <div class="progress-meta">
              <span id="hittingRecordIndex">Session 1 of 1</span>
              <span id="hittingRecordDate">Jan 22, 2026</span>
              <div class="attachments-indicator" id="hittingAttachments"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="category-card" id="card-fielding">
        <div class="section-title">Fielding</div>
        <div class="progress-panel" id="progress-fielding">
          <div class="progress-record" id="fieldingRecord">
            <div class="rating-group-grid"></div>
            <div class="progress-meta">
              <span id="fieldingRecordIndex">Session 1 of 1</span>
              <span id="fieldingRecordDate">Jan 22, 2026</span>
              <div class="attachments-indicator" id="fieldingAttachments"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="category-card" id="card-intangibles">
        <div class="section-title">Speed & Intangibles</div>
        <div class="progress-panel" id="progress-intangibles">
          <div class="progress-record" id="intangiblesRecord">
            <div class="rating-group-grid"></div>
            <div class="progress-meta">
              <span id="intangiblesRecordIndex">Session 1 of 1</span>
              <span id="intangiblesRecordDate">Jan 22, 2026</span>
              <div class="attachments-indicator" id="intangiblesAttachments"></div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<div id="attachmentModal" class="modal hidden">
  <div class="modal-content" id="attachmentModalContent"></div>
</div>


<div id="attachmentViewerModal" class="modal hidden attachment-viewer-modal">
  <div class="attachment-viewer-content" id="attachmentViewerContent"></div>
</div>

<button id="migrateTeamsBtn" class="danger-button">
  Migrate Old Teams
</button>

<div id="uploadOverlay" class="upload-overlay hidden">
  <div class="upload-overlay-content">
    <div id="uploadOverlaySpinner" class="spinner hidden"></div>
    <div id="uploadOverlayMessage">Uploading‚Ä¶</div>

    <div id="uploadBar" class="upload-bar">
      <div id="uploadBarFill"></div>
    </div>
  </div>
</div>

<input id="nativeVideoInput" type="file" accept="video/*" capture="camera" class="invisible-file-input">

<!-- 1. CONFIG & GLOBALS -->
<script data-chunk="config-and-globals">
  const API_BASE = "https://athlete-vision-five.vercel.app/api";

  const RATING_CONFIGS = {
    1: {
      hitting: [
        { field: "swing",        label: "Swing",        max: 4, weight: 1, order: 1 },
        { field: "contact",      label: "Contact",      max: 4, weight: 1, order: 2 },
        { field: "power",        label: "Power",        max: 4, weight: 1, order: 3 }
      ],
      fielding: [
        { field: "glove",        label: "Glove",        max: 4, weight: 1, order: 1 },
        { field: "arm",          label: "Arm",          max: 4, weight: 1, order: 2 },
        { field: "footwork",     label: "Footwork",     max: 4, weight: 1, order: 3 }
      ],
      intangibles: [
        { field: "speed",        label: "Speed",        max: 4, weight: 1, order: 1 },
        { field: "hustle",       label: "Hustle",       max: 4, weight: 1, order: 2 },
        { field: "coachability", label: "Coachability", max: 4, weight: 1, order: 3 }
      ]
    }
  };
  const LATEST_CONFIG_VERSION = 1;

  let currentTeamName = null;
  let currentTeamKey = null;
  let currentTeamId = null;
  let players = [];
  let current = 0;
  let sortState = { column: null, direction: 1 };
  let sortedPlayerOrder = [];
  let progressState = {
    hitting: { index: 0 },
    fielding: { index: 0 },
    intangibles: { index: 0 }
  };
</script>

<!-- 2. DATA STORE & BACKEND API -->
<script data-chunk="data-store-and-api">
  async function loadPlayers(teamId) {
    const key = "team_" + teamId;

    // 1. Try local cache first
    const raw = localStorage.getItem(key);
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) return parsed;
      } catch {
        console.warn("Corrupt local players for", teamId, "‚Äî refetching");
      }
    }

    // 2. Fetch from backend
    const res = await fetch(`${API_BASE}/load-players?teamId=${teamId}`);
    if (!res.ok) throw new Error("Failed to load players");

    const players = await res.json();

    // 3. Cache for future fast loads
    localStorage.setItem(key, JSON.stringify(players));

    return players;
  }

  async function refreshPlayers(teamId) {
    if (!teamId) {
      console.error("refreshPlayers requires a teamId");
      return [];
    }

    const res = await fetch(`${API_BASE}/load-players?teamId=${teamId}`);
    if (!res.ok) {
      console.error("Failed to refresh players");
      return [];
    }

    const loaded = await res.json();
    localStorage.setItem("team_" + teamId, JSON.stringify(loaded));
    return loaded;
  }

  // ‚≠ê Unified save endpoint (single or many)
  async function savePlayers(players) {
    if (!currentTeamId) {
      console.error("savePlayers requires teamId");
      return false;
    }

    let teamId = currentTeamId;
    // Update local cache
    localStorage.setItem("team_" + currentTeamId, JSON.stringify(players));

    // Send to backend
    const res = await fetch(`${API_BASE}/save-players`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ players, teamId })
    });

    if (!res.ok) {
      console.error("Failed to save players", await res.text());
      return false;
    }

    return true;
  }

  // ‚≠ê Save a single player using the unified endpoint
  async function savePlayer(player) {
    if (!currentTeamId) {
      console.error("savePlayer requires teamId");
      return false;
    }

    // Load current cache
    const key = "team_" + currentTeamId;
    const cached = JSON.parse(localStorage.getItem(key) || "[]");

    const idx = cached.findIndex(p => p.id === player.id);
    if (idx >= 0) cached[idx] = player;
    else cached.push(player);

    // Delegate to unified save
    return await savePlayers(cached, currentTeamId);
  }

  // ‚≠ê Seed team using UUID teamId (NOT team name)
  async function seedTeam(teamId) {
    const names = [
      "ILeiana Aguilar", "Jana Almasri", "Juliet Apodaca", "Alannah Arguello",
      "Shealey Belardes", "Alexis Berggren", "Katelyn Borecky", "Cambria Brosnan",
      "Angela Calixto", "Natalie Cervantes", "Penelope Cuevas", "Avery Dean",
      "Alyson Eden", "Adeline Esquivel", "Lily Esquivel", "Aryanna Fernandez",
      "Harper Flores", "Kaylee Flores", "Haley Franco", "Evelyn Gardino",
      "Maddison Garcia", "Cora Gottlieb", "Tavyn Green", "Jaedyn Kandyce Grill",
      "Leilani Hernandez", "Kara Hutchinson", "Lilyana Jordan", "Aria Lopez",
      "Bella Lopez", "Bianca Lopez", "Noelle Marquez", "Caroline McDonald",
      "Mila Medina", "Samantha Mendoza", "Dryden Miyajima", "Kennedy Moralez",
      "Madison Murphy", "Hannah Nack", "Leiyanah Paipa", "Victoria Parker",
      "Khloe Pettit", "Katalina Ponce", "Cierra Prieto", "Madison Pulver",
      "Aiyana Renteria", "Kaylee Rhodes", "Alysse Robles", "Daliah Sanchez",
      "Savannah Springsteen", "Riley Tanner", "Evelyn Tellez", "Isabel Torres",
      "Noshla Turner", "Uushla Turner", "Ariyana Ari Tyler", "Olivia Vallejos",
      "Stella Vega", "Amelia Webber", "Gloria Wiebel"
    ];

    const roster = names.map(n => ({
      id: crypto.randomUUID(),
      teamId,        // UUID now
      name: n,
      progress: {},
      notes: "",
      throws: ""
    }));

    await savePlayers(roster);
    players = roster;

    alert("Team seeded!");
  }
</script>

<!-- 3. NORMALIZATION & PROGRESS MODEL -->
<script data-chunk="normalization-and-progress-model">
  function normalizeRecord(rec, category) {
    if (!rec.sessionId) {
      rec.sessionId = crypto.randomUUID();
    }

    let version = rec.configVersion || 1;
    if (!RATING_CONFIGS[version]) {
      version = 1;
    }
    rec.configVersion = version;

    const cfg = RATING_CONFIGS[version][category];
    if (!cfg) return rec;

    if (!rec.media || !rec.media.attachments) {
      rec.media = { attachments: [] };
    }

    cfg.forEach(item => {
      if (rec[item.field] == null) {
        rec[item.field] = 1;
      }
    });

    return rec;
  }

  function normalizePlayer(p) {
    if (!p.id) {
      p.id = crypto.randomUUID();
    }

    if (!p.progress) p.progress = {};
    const cats = ["hitting", "fielding", "intangibles"];

    cats.forEach(cat => {
      if (!Array.isArray(p.progress[cat]) || p.progress[cat].length === 0) {
        const today = new Date().toISOString().split("T")[0];
        const version = 1;
        const cfg = RATING_CONFIGS[version][cat];

        const rec = {
          date: today,
          media: { attachments: [] },
          configVersion: version
        };

        cfg.forEach(item => {
          rec[item.field] = 1;
        });

        p.progress[cat] = [rec];
      }

      p.progress[cat] = p.progress[cat].map(rec => normalizeRecord(rec, cat));
    });

    return p;
  }

  function normalizeAllPlayers() {
    players = players.map(p => normalizePlayer(p));
    save();
  }

  function defaultProgressFor(player) {
    const today = new Date().toISOString().split("T")[0];

    function makeCategory(cat) {
      const cfg = RATING_CONFIGS[LATEST_CONFIG_VERSION][cat];

      const obj = {
        date: today,
        media: { attachments: [] },
        configVersion: LATEST_CONFIG_VERSION
      };

      cfg.forEach(item => {
        obj[item.field] = player[item.field] ?? 1;
      });

      return [obj];
    }

    return {
      hitting: makeCategory("hitting"),
      fielding: makeCategory("fielding"),
      intangibles: makeCategory("intangibles")
    };
  }

  function ensurePlayerProgress(p) {
    if (!p.progress) p.progress = {};

    ["hitting", "fielding", "intangibles"].forEach(cat => {
      if (!Array.isArray(p.progress[cat]) || p.progress[cat].length === 0) {
        const today = new Date().toISOString().split("T")[0];
        const cfg = RATING_CONFIGS[1][cat];

        const rec = {
          date: today,
          media: { attachments: [] },
          configVersion: 1
        };

        cfg.forEach(item => {
          rec[item.field] = 1;
        });

        p.progress[cat] = [rec];
      }
    });

    return p;
  }

  function getPlayerLatestVersion(p) {
    const cats = ["hitting", "fielding", "intangibles"];
    let version = 1;

    cats.forEach(cat => {
      const rec = p.progress[cat][0];
      if (rec && rec.configVersion && rec.configVersion > version) {
        version = rec.configVersion;
      }
    });

    return version;
  }

  function ensurePlayerIds() {
    for (const player of players) {
      if (!player.id) {
        player.id = crypto.randomUUID();
      }
    }
    save();
  }
</script>

<!-- 4. TEAM MANAGEMENT & CSV -->
<script data-chunk="team-management-and-csv">
  async function migrateLocalTeams() {
    // Remove messed up team
    JSON.parse(localStorage.getItem("team_d609bf49-b995-46e0-8b67-a89956312190"))[0].name=="Player 1" && localStorage.setItem("team_d609bf49-b995-46e0-8b67-a89956312190", null)
    const raw = localStorage.getItem("teamNames");
    const alreadyMigrated = localStorage.getItem("teams");

    // If already migrated ‚Üí do nothing
    if (alreadyMigrated) {
      console.log("Teams already migrated ‚Äî skipping");
      return;
    }

    // Nothing to migrate
    if (!raw) {
      console.log("No legacy teamNames found ‚Äî skipping migration");
      return;
    }

    let names;
    try {
      names = JSON.parse(raw);
    } catch {
      console.warn("Corrupt teamNames JSON ‚Äî aborting migration");
      return;
    }

    // Must be a non-empty array of strings
    if (!Array.isArray(names) || names.length === 0) {
      console.log("Legacy teamNames empty ‚Äî skipping migration");
      return;
    }

    // Fetch real teams from backend
    const res = await fetch(`${API_BASE}/list-teams`);
    if (!res.ok) {
      console.error("Failed to fetch teams from backend ‚Äî migration aborted");
      return;
    }

    const { teams } = await res.json();

    if (!Array.isArray(teams) || teams.length === 0) {
      console.warn("Backend returned no teams ‚Äî migration aborted");
      return;
    }

    // Map old names ‚Üí new objects (best effort)
    const mapped = names
      .map(n => teams.find(t => t.name === n))
      .filter(Boolean);

    if (mapped.length === 0) {
      console.warn("No matching teams found for legacy names ‚Äî migration aborted");
      return;
    }

    // Save new structure
    localStorage.setItem("teams", JSON.stringify(mapped));
    localStorage.removeItem("teamNames");

    console.log("Migration complete:", mapped);
  }

  document.getElementById("migrateTeamsBtn").addEventListener("click", async () => {
    await migrateLocalTeams();
    alert("Migration complete!");
    renderTeamList();
  });

  if (localStorage.getItem("teams")) {
    document.getElementById("migrateTeamsBtn").disabled = true;
    document.getElementById("migrateTeamsBtn").textContent = "Teams Already Migrated";
  }

  async function getTeams() {
    const raw = localStorage.getItem("teams");

    if (raw) {
      try {
        const parsed = JSON.parse(raw);

        // Validate: must be array of {id, name}
        if (
          Array.isArray(parsed) &&
          parsed.every(t => t && typeof t.id === "string" && typeof t.name === "string")
        ) {
          return parsed;
        }
      } catch {
        console.warn("Corrupt teams in localStorage, resetting...");
      }
    }

    // Fetch from backend
    const teams = await fetchTeamsFromDatabase();

    // Persist only if valid
    if (Array.isArray(teams)) {
      localStorage.setItem("teams", JSON.stringify(teams));
      return teams;
    }

    return [];
  }

  async function fetchTeamsFromDatabase() {
    try {
      const res = await fetch(`${API_BASE}/list-teams`);
      if (!res.ok) throw new Error("Failed to fetch teams");
      const data = await res.json();
      return data.teams || [];
    } catch (err) {
      console.error("Error fetching teams:", err);
      return [];
    }
  }

  async function renderTeamList() {
    const container = document.getElementById("teamList");
    container.innerHTML = "";

    const teams = await getTeams();

    if (teams.length === 0) {
      const empty = document.createElement("div");
      empty.className = "team-empty";
      empty.textContent = "No teams yet. Create one below.";
      container.appendChild(empty);
      return;
    }

    teams.forEach(team => {
      const div = document.createElement("div");
      div.className = "team-item";
      div.textContent = team.name;

      div.addEventListener("click", () => {
        selectTeam(team.id, team.name);
      });

      container.appendChild(div);
    });
  }

  async function createTeam() {
    const input = document.getElementById("newTeamName");
    const name = input.value.trim();
    if (!name) return;

    // Save to backend
    await fetch(`${API_BASE}/create-team`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ teamName: name })
    });

    // Update local cache
    const names = await getTeamNames();
    if (!names.includes(name)) {
      names.push(name);
      localStorage.setItem("teamNames", JSON.stringify(names));
    }

    input.value = "";
    renderTeamList();

    await seedTeam(name);
  }

  async function selectTeam(teamId, teamName) {
    currentTeamId = teamId;
    currentTeamName = teamName;

    players = await loadPlayers(teamId);
    current = 0;

    document.getElementById("teamSelectScreen").classList.add("hidden");
    document.getElementById("mainApp").classList.remove("hidden");

    loadPlayer();
  }

  function showTeamSelect() {
    document.getElementById("mainApp").classList.add("hidden");
    document.getElementById("teamSelectScreen").classList.remove("hidden");
    renderTeamList();
  }

  function triggerCSVImport() {
    document.getElementById("teamCSVInput").click();
  }

  document.getElementById("teamCSVInput").addEventListener("change", function () {
    const file = this.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
      importTeamFromCSV(e.target.result, file.name);
    };
    reader.readAsText(file);
  });

  function importTeamFromCSV(csvText, filename) {
    const lines = csvText.trim().split(/\r?\n/);
    if (lines.length < 2) {
      alert("CSV appears empty or invalid.");
      return;
    }

    const headers = lines[0].split(",").map(h => h.trim());
    const importedPlayers = [];

    for (let i = 1; i < lines.length; i++) {
      const raw = lines[i].trim();
      if (!raw) continue;

      const cols = raw.split(",");
      const p = {};

      headers.forEach((h, idx) => {
        p[h] = cols[idx] ? cols[idx].trim() : "";
      });

      p.name = p.name || p.Name || "";
      p.throws = p.throws || p.Throws || "";
      p.notes = (p.notes && p.notes.replace(/"/g, "")) || "";

      ["swing","contact","power","glove","arm","footwork","speed","hustle","coachability"]
        .forEach(f => p[f] = Number(p[f]) || 0);

      if (p.photo) p.photo = p.photo;

      importedPlayers.push(p);
    }

    const teamName = filename.replace(".csv", "");
    const key = "team_" + teamName;

    localStorage.setItem(key, JSON.stringify(importedPlayers));

    alert(`Imported ${importedPlayers.length} players into team: ${teamName}`);
    renderTeamList();
  }

  function exportCSV() {
    if (!players || players.length === 0) return;

    const fields = [
      "name","throws",
      "swing","contact","power",
      "glove","arm","footwork",
      "speed","hustle","coachability",
      "notes"
    ];

    const header = fields.join(",");
    const rows = players.map(p => {
      const player = p || {};
      return fields.map(field => {
        let value = player[field];

        if (value === undefined || value === null) value = "";
        value = String(value).replace(/"/g, '""');

        if (value.includes(",") || value.includes("\n") || value.includes("\"")) {
          value = `"${value}"`;
        }

        return value;
      }).join(",");
    });

    const csv = [header, ...rows].join("\n");
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    const teamName = currentTeamKey ? currentTeamKey.replace("team_", "") : "team";
    a.href = url;
    a.download = teamName + "_players.csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
</script>

<!-- 5. PLAYER NAV, SUMMARY, TABLES, EXPORT -->
<script data-chunk="player-nav-summary-tables">
  function save() {
    if (!players[current]) return;
    savePlayer(players[current]);
  }

  function updateSummary() {
    const p = players[current] || {};
    const fields = [
      "swing","contact","power",
      "glove","arm","footwork",
      "speed","hustle","coachability"
    ];

    let sum = 0, count = 0;
    fields.forEach(f => {
      if (p[f] >= 1 && p[f] <= 4) {
        sum += p[f];
        count++;
      }
    });

    const avg = count ? sum / count : 0;
    const percent = (sum / 36 * 100).toFixed(2);

    document.getElementById("summaryScore").textContent = "Score: " + sum;
    document.getElementById("summaryAvg").textContent = "Category Avg: " + avg.toFixed(1);
    document.getElementById("summaryCompletion").textContent = Math.round(percent) + "%";
    document.getElementById("summaryProgress").style.width = percent + "%";
  }

  function loadPlayer() {
    const p = players[current] || {};
    if (!p.progress) {
      p.progress = defaultProgressFor(p);
      save();
      progressState.hitting.index = 0;
      progressState.fielding.index = 0;
      progressState.intangibles.index = 0;
    }

    document.getElementById("playerNameDisplay").textContent = p.name || `Player ${current + 1}`;

    document.querySelectorAll("input[data-field], textarea[data-field]").forEach(el => {
      const field = el.getAttribute("data-field");
      el.value = p[field] || "";
    });

    document.querySelectorAll(".rating-circles").forEach(group => {
      const field = group.getAttribute("data-field");
      group.querySelectorAll(".circle").forEach(c => {
        c.classList.remove("selected");
        const level = parseInt(c.getAttribute("data-level"), 10);
        if (p[field] === level) {
          c.classList.add("selected");
        }
      });
    });

    const throwsValue = p.throws || "";
    document.querySelectorAll(".throws-option").forEach(opt => {
      const val = opt.getAttribute("data-throws-value");
      if (val === throwsValue) opt.classList.add("selected");
      else opt.classList.remove("selected");
    });

    const profilePic = document.getElementById("profilePic");
    if (p.photo) {
      profilePic.src = p.photo;
    } else {
      profilePic.src = "";
    }

    updateSummary();

    progressState.hitting.index = 0;
    progressState.fielding.index = 0;
    progressState.intangibles.index = 0;

    renderProgressPanel("hitting");
    renderProgressPanel("fielding");
    renderProgressPanel("intangibles");
  }

  function addPlayer() {
    players.push({});
    current = players.length - 1;
    save();
    loadPlayer();
  }

  function deletePlayer() {
    if (players.length === 1) return;
    players.splice(current, 1);
    current = Math.max(0, current - 1);
    save();
    loadPlayer();
  }

  function changePlayer(direction) {
    const currentSortedIndex = sortedPlayerOrder.indexOf(current);
    const newSortedIndex = currentSortedIndex + direction;

    if (newSortedIndex < 0 || newSortedIndex >= sortedPlayerOrder.length) return;

    current = sortedPlayerOrder[newSortedIndex];
    loadPlayer();
    updateNavBar();
  }

  function updateNavBar() {
    const sortedIndex = sortedPlayerOrder.indexOf(current);
    const title = document.getElementById("navPlayerText");

    title.textContent = `Player ${sortedIndex + 1} of ${sortedPlayerOrder.length}`;

    document.getElementById("navPrevPlayer").disabled = sortedIndex === 0;
    document.getElementById("navNextPlayer").disabled = sortedIndex === sortedPlayerOrder.length - 1;
  }

  function openAllPlayersSelector() {
    buildPlayersTable();
    hideAllViews();
    document.getElementById("allPlayersView").style.display = "block";
    highlightCurrentPlayerInList();
  }

  function highlightCurrentPlayerInList() {
    const rows = document.querySelectorAll("#playersTable tbody tr");

    rows.forEach((row, index) => {
      if (index === current) {
        row.style.background = "#d0e7ff";
        row.style.fontWeight = "600";
      } else {
        row.style.background = "";
        row.style.fontWeight = "";
      }
    });
  }

  function hideAllViews() {
    document.getElementById("playerCard").style.display = "none";
    document.getElementById("allPlayersView").style.display = "none";
    const summary = document.getElementById("teamSummaryView");
    if (summary) summary.style.display = "none";
  }

  function toggleAllPlayers() {
    const card = document.getElementById("playerCard");
    const list = document.getElementById("allPlayersView");

    if (list.style.display === "none" || list.style.display === "") {
      buildPlayersTable();
      hideAllViews();
      list.style.display = "block";
    } else {
      hideAllViews();
      card.style.display = "block";
    }
  }

  function buildPlayersTable() {
    const tbody = document.querySelector("#playersTable tbody");
    const thead = document.querySelector("#playersTable thead");
    tbody.innerHTML = "";

    const rows = players.map((p, index) => {
      ensurePlayerProgress(p);
      const latestVersion = getPlayerLatestVersion(p);
      const cfg = RATING_CONFIGS[latestVersion];

      function categoryStats(cat) {
        const items = cfg[cat];

        let sum = 0;
        let maxSum = 0;

        items.forEach(item => {
          const val = p[item.field];
          if (val >= 1 && val <= item.max) {
            sum += val * item.weight;
          }
          maxSum += item.max * item.weight;
        });

        const avg = sum / items.length;
        return { avg, sum, maxSum };
      }

      const hit = categoryStats("hitting");
      const fld = categoryStats("fielding");
      const intg = categoryStats("intangibles");

      const overall = hit.sum + fld.sum + intg.sum;
      const overallMax = hit.maxSum + fld.maxSum + intg.maxSum;
      const percent = overallMax ? overall / overallMax : 0;

      return {
        index,
        seed: index + 1,
        name: p.name || `Player ${index + 1}`,
        hitting: hit.avg,
        fielding: fld.avg,
        intangibles: intg.avg,
        overall,
        percent
      };
    });

    if (sortState.column) {
      rows.sort((a, b) => {
        const col = sortState.column;
        const dir = sortState.direction;

        if (typeof a[col] === "string") {
          return a[col].localeCompare(b[col]) * dir;
        }
        return (a[col] - b[col]) * dir;
      });
    }
    sortedPlayerOrder = rows.map(r => r.index);

    rows.forEach(r => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.seed}</td>
        <td>${r.name}</td>
        <td>${r.hitting.toFixed(1)}</td>
        <td>${r.fielding.toFixed(1)}</td>
        <td>${r.intangibles.toFixed(1)}</td>
        <td>${r.overall.toFixed(1)}</td>
        <td>${Math.round(r.percent * 100)}%</td>
      `;

      tr.addEventListener("click", () => {
        current = r.index;
        updateNavBar();
        loadPlayer();
        hideAllViews();
        document.getElementById("playerCard").style.display = "block";
      });

      tbody.appendChild(tr);
    });

    const headers = thead.querySelectorAll("th");
    headers.forEach((th, i) => {
      const colMap = [
        "seed",
        "name",
        "hitting",
        "fielding",
        "intangibles",
        "overall",
        "percent"
      ];

      const col = colMap[i];

      th.onclick = () => {
        if (sortState.column === col) {
          sortState.direction *= -1;
        } else {
          sortState.column = col;
          sortState.direction = 1;
        }

        headers.forEach(h => h.classList.remove("sorted-asc", "sorted-desc"));
        th.classList.add(sortState.direction === 1 ? "sorted-asc" : "sorted-desc");

        buildPlayersTable();
      };
    });
  }

  async function exportPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: "pt", format: "letter" });

    const teamName = currentTeamKey ? currentTeamKey.replace("team_", "") : "Team";
    let y = 40;

    doc.setFontSize(18);
    doc.text(`${teamName} ‚Äì Player Roster`, 40, y);
    y += 30;

    doc.setFontSize(12);

    for (let i = 0; i < players.length; i++) {
      const p = players[i];

      doc.setFontSize(14);
      doc.text(`${i + 1}. ${p.name || "Unnamed Player"}`, 40, y);
      y += 20;
      doc.setFontSize(12);

      if (p.photo) {
        try {
          doc.addImage(p.photo, "JPEG", 40, y, 80, 80);
        } catch (e) {
          console.warn("Image failed to load for PDF:", e);
        }
      }

      let infoY = y;
      if (p.photo) infoY += 90;

      doc.text(`Throws/Bats: ${p.throws || "-"}`, 140, y + 15);

      const ratingFields = [
        ["Swing", p.swing],
        ["Contact", p.contact],
        ["Power", p.power],
        ["Glove", p.glove],
        ["Arm", p.arm],
        ["Footwork", p.footwork],
        ["Speed", p.speed],
        ["Hustle", p.hustle],
        ["Coachability", p.coachability]
      ];

      let ry = infoY;
      ratingFields.forEach(([label, val]) => {
        doc.text(`${label}: ${val || "-"}`, 40, ry);
        ry += 16;
      });

      if (p.notes) {
        ry += 10;
        doc.text("Notes:", 40, ry);
        ry += 14;

        const wrapped = doc.splitTextToSize(p.notes, 520);
        doc.text(wrapped, 40, ry);
        ry += wrapped.length * 14;
      }

      y = ry + 20;

      if (y > 700) {
        doc.addPage();
        y = 40;
      }
    }

    doc.save(`${teamName}_players.pdf`);
  }

  function toggleTeamSummary() {
    const summary = document.getElementById("teamSummaryView");
    const card = document.getElementById("playerCard");

    if (summary.style.display === "none" || summary.style.display === "") {
      buildTeamSummary();
      hideAllViews();
      summary.style.display = "block";
    } else {
      hideAllViews();
      card.style.display = "block";
    }
  }

  function buildTeamSummary() {
    const tbody = document.querySelector("#teamSummaryTable tbody");
    tbody.innerHTML = "";

    const allItems = [];

    Object.values(RATING_CONFIGS).forEach(cfg => {
      if (!cfg) return;

      Object.keys(cfg).forEach(cat => {
        const items = cfg[cat];
        if (!Array.isArray(items)) return;

        items.forEach(item => {
          if (!allItems.find(x => x.field === item.field)) {
            allItems.push({
              field: item.field,
              label: item.label
            });
          }
        });
      });
    });

    function avgOf(fields) {
      let sum = 0;
      let weightSum = 0;

      players.forEach(p => {
        const latestVersion = p.progress.hitting[0].configVersion;
        const cfg = RATING_CONFIGS[latestVersion];

        fields.forEach(f => {
          const item = Object.values(cfg)
            .flat()
            .find(x => x.field === f.field);

          if (!item) return;

          const val = p[f.field];
          if (val >= 1 && val <= item.max) {
            sum += val * item.weight;
            weightSum += item.weight;
          }
        });
      });
      return weightSum ? sum / weightSum : 0;
    }

    const sortedSubcats = allItems.sort((a, b) =>
      a.label.localeCompare(b.label)
    );

    sortedSubcats.forEach(item => {
      const avg = avgOf([item]).toFixed(2);
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${item.label}</td>
        <td>${avg}</td>
      `;
      tbody.appendChild(tr);
    });

    const latestCfg = RATING_CONFIGS[LATEST_CONFIG_VERSION];

    const groupLabels = {
      hitting: "Hitting",
      fielding: "Fielding",
      intangibles: "Speed & Intangibles"
    };

    Object.keys(latestCfg)
      .sort((a, b) => groupLabels[a].localeCompare(groupLabels[b]))
      .forEach(cat => {
        const items = latestCfg[cat];
        const avg = avgOf(items).toFixed(2);
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><strong>${groupLabels[cat]}</strong></td>
          <td><strong>${avg}</strong></td>
        `;
        tbody.appendChild(tr);
      });

    const overall = avgOf(allItems).toFixed(2);

    const trOverall = document.createElement("tr");
    trOverall.innerHTML = `
      <td><strong>Overall Team Average</strong></td>
      <td><strong>${overall}</strong></td>
    `;
    tbody.appendChild(trOverall);

    const trCount = document.createElement("tr");
    trCount.innerHTML = `
      <td><strong>Total Players</strong></td>
      <td><strong>${players.length}</strong></td>
    `;
    tbody.appendChild(trCount);
  }
</script>

<!-- 6. MEDIA, ATTACHMENTS, PURGE -->
<script data-chunk="media-and-attachments">
  async function handleFileSelected(e) {
    const overlay = document.getElementById("uploadOverlay");

    try {
      const file = e.target.files[0];
      if (!file) return;

      const category = e.target.dataset.category;
      if (!category) {
        console.error("No category associated with file input");
        return;
      }

      // Show overlay
      showUploadOverlay()

      if (!progressState[category]) {
        console.warn("progressState missing for category, initializing default");
        progressState[category] = { index: 0 };
      }
      const index = progressState[category].index;
      const player = players[current];
      const records = player.progress[category];
      const record = records[index];

      const timestamp = new Date().toISOString();
      const clipNumber = nextClipNumber(record);

      const filename = buildAttachmentFilename({
        timestamp,
        category,
        sessionId: record.sessionId,
        clipNumber,
        file
      });

      // 1) Ask backend for signed upload URL + public URL
      const metaRes = await fetch(`${API_BASE}/upload`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          playerId: player.id,
          sessionId: record.sessionId,
          category,
          filename,
          mimeType: file.type
        })
      });

      if (!metaRes.ok) {
        console.error("Failed to get upload URL", await metaRes.text());
        alert("Failed to prepare upload.");
        return;
      }

      const { path, uploadUrl, publicUrl, contentType } = await metaRes.json();

      // 2) Upload directly to Supabase using signed URL with progress
      const uploadBarFill = document.getElementById("uploadBarFill");
      uploadBarFill.style.width = "0%";

      await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.withCredentials = false;
        xhr.open("PUT", uploadUrl);

        xhr.upload.onprogress = e => {
          if (e.lengthComputable) {
            const pct = (e.loaded / e.total) * 100;
            uploadBarFill.style.width = pct + "%";
          }
        };

        xhr.onload = () => xhr.status < 300 ? resolve() : reject(xhr.responseText);
        xhr.onerror = reject;

        xhr.setRequestHeader("Content-Type", contentType || file.type);
        xhr.send(file);
      });

      // 3) Build attachment metadata (same shape as before)
      const attachment = {
        id: crypto.randomUUID(),
        type: file.type.startsWith("video") ? "video" : "image",
        supabasePath: path,
        url: publicUrl,
        playerId: player.id,
        category,
        sessionId: record.sessionId,
        timestamp,
        clipNumber,
        evaluation: {
          evaluated: false,
          summary: null,
          keyPoints: [],
          score: null,
          rawResponse: null
        },
        purged: false
      };

      record.media.attachments.push(attachment);
      save();

      renderProgressPanel(category);
      hideOverlay();

      showProcessingOverlay("Detecting skill events‚Ä¶");
    
      // 4) Call trim-video to convert raw video ‚Üí event clips
      const trimRes = await fetch(`${API_BASE}/trim-video`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          supabasePath: path,
          playerId: player.id,
          sessionId: record.sessionId,
          category,
          filename
        })
      });
      hideOverlay();

      if (!trimRes.ok) {
        console.error("Trim failed", await trimRes.text());
        alert("Video uploaded, but trimming failed.");
        return;
      }

      const { events } = await trimRes.json();

      // 5) Remove the original raw attachment
      record.media.attachments = record.media.attachments.filter(a => a.id !== attachment.id);

      // 6) Insert event attachments
      events.forEach(evt => {
        record.media.attachments.push({
          id: crypto.randomUUID(),
          type: "video",
          supabasePath: evt.path,
          url: evt.url,
          playerId: player.id,
          category,
          sessionId: record.sessionId,
          timestamp,
          clipNumber: evt.index,
          eventIndex: evt.index,
          evaluation: {
            evaluated: false,
            summary: null,
            keyPoints: [],
            score: null,
            rawResponse: null
          },
          purged: false
        });
      });

      save();

      renderProgressPanel(category);

    } catch (err) {
      console.error("Upload error:", err);
      alert("Upload failed.");
    } finally {
      // Always hide overlay
      overlay.classList.add("hidden");

      // Reset input so same file can be selected again
      if (e.target) e.target.value = "";
    }
  }

  function handleDirectFileUpload(file, category) {
    const fakeEvent = { target: { files: [file], dataset: { category } } };
    handleFileSelected(fakeEvent);
  }

  function hideOverlay() {
    const overlay = document.getElementById("uploadOverlay");
    overlay.classList.add("hidden");
  }

  function showUploadOverlay() {
    const overlay = document.getElementById("uploadOverlay");
    const msg = document.getElementById("uploadOverlayMessage");
    const spinner = document.getElementById("uploadOverlaySpinner");
    const bar = document.getElementById("uploadBar");

    msg.textContent = "Uploading‚Ä¶";
    spinner.classList.add("hidden");
    bar.classList.remove("hidden");

    overlay.classList.remove("hidden");
  }

  function showProcessingOverlay(message = "Processing‚Ä¶") {
    const overlay = document.getElementById("uploadOverlay");
    const msg = document.getElementById("uploadOverlayMessage");
    const spinner = document.getElementById("uploadOverlaySpinner");
    const bar = document.getElementById("uploadBar");

    msg.textContent = message;
    spinner.classList.remove("hidden");
    bar.classList.add("hidden"); // hide progress bar during trimming

    overlay.classList.remove("hidden");
  }

  async function record720pVideo() {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: { ideal: 1280 },
        height: { ideal: 720 },
        frameRate: { ideal: 30 }
      },
      audio: false
    });

    const recorder = new MediaRecorder(stream, {
      mimeType: "video/webm;codecs=vp9"
    });

    const chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);

    recorder.start();

    return new Promise(resolve => {
      setTimeout(() => {
        recorder.stop();
        stream.getTracks().forEach(t => t.stop());
      }, 5000); // 5 seconds max
      recorder.onstop = () => resolve(new Blob(chunks, { type: "video/webm" }));
    });
  }

  async function nuclearPurge() {
    const allPaths = [];

    for (const player of players) {
      for (const category in player.progress) {
        for (const record of player.progress[category]) {
          for (const att of record.media.attachments) {
            if (att.supabasePath) allPaths.push(att.supabasePath);
          }
        }
      }
    }

    if (allPaths.length > 0) {
      await fetch(`${API_BASE}/delete-media`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ paths: allPaths })
      });
    }

    purgeAllLocalAttachments();

    progressState = {};
    current = 0;

    const firstCategory = Object.keys(RATING_CONFIGS[1])[0];
    progressState[firstCategory] = { index: 0 };

    renderProgressPanel(firstCategory);
  }

  function purgeAllLocalAttachments() {
    for (const player of players) {
      if (!player.progress) continue;
      for (const category in player.progress) {
        for (const record of player.progress[category]) {
          if (record.media && record.media.attachments) {
            record.media.attachments = [];
          }
        }
      }
    }

    save();
    console.log("All local attachment metadata purged.");
  }

  function buildAttachmentFilename({ timestamp, category, sessionId, clipNumber, file }) {
    const ext = file.name.split(".").pop().toLowerCase();
    return `${timestamp}_${category}_${sessionId}_C${clipNumber}.${ext}`;
  }

  function nextClipNumber(record) {
    const clips = record.media.attachments;
    return clips.length + 1;
  }

  async function evaluateCategory(category) {
    const record = players[current].progress[category][progressState[category].index];
    const userTier = record.userTier || "free";

    showProcessingOverlay("Evaluating skill events‚Ä¶");

    try {
      const data = await evaluateCategoryBatch(record, category, userTier);
      applyEvaluationsToAttachments(record, category, data.evaluations);
      savePlayer(players[current]);
      renderProgressPanel(category);

      if (data.partialFailure) {
        alert(`Some events could not be evaluated (${data.failureCount} failed).`);
      }
    } catch (err) {
      alert("Evaluation failed: " + err.message);
    } finally {
      hideOverlay();
    }
  }

  function applyEvaluationsToAttachments(category, data) {
    const { evaluations } = data;

    evaluations.forEach(ev => {
      const att = record.media.attachments.find(
        a => a.category === category && a.eventIndex === ev.eventIndex
      );

      if (!att) return;

      if (ev.success) {
        att.evaluation = {
          evaluated: true,
          provider: ev.provider,
          summary: ev.summary,
          keyPoints: ev.keyPoints,
          score: ev.score,
          rawResponse: ev.rawResponse
        };
      } else {
        att.evaluation = {
          evaluated: false,
          provider: null,
          summary: null,
          keyPoints: [],
          score: null,
          rawResponse: null,
          error: ev.error
        };
      }
    });
  }

  function retryFailed(category) {
    const failedEvents = record.media.attachments
      .filter(a => a.category === category && a.evaluation.error)
      .map(a => ({
        eventIndex: a.eventIndex,
        url: a.url
      }));

    if (failedEvents.length === 0) return;

    evaluateCategory(category, failedEvents);
  }

</script>

<!-- 7. PROGRESS UI, SWIPE, ATTACHMENTS, EVALUATION -->
<script data-chunk="progress-ui-and-swipe">
  function initProgressSwipeListeners() {
    setupSwipe("hitting");
    setupSwipe("fielding");
    setupSwipe("intangibles");
  }

  function setupSwipe(category) {
    const panel = document.getElementById(`progress-${category}`);

    let startX = 0;
    let startY = 0;
    let endX = 0;
    let didMove = false;

    panel.addEventListener("touchstart", e => {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      didMove = false;
    });

    panel.addEventListener("touchmove", e => {
      const x = e.touches[0].clientX;
      const y = e.touches[0].clientY;

      endX = x;

      const dx = Math.abs(x - startX);
      const dy = Math.abs(y - startY);

      if (dx > 25 && dx > dy) {
        didMove = true;
      }
    });

    panel.addEventListener("touchend", () => {
      if (!didMove) return;

      const delta = endX - startX;
      if (Math.abs(delta) < 60) return;

      if (delta < 0) {
        handleSwipeLeft(category);
      } else {
        handleSwipeRight(category);
      }
    });

    function handleSwipeLeft(cat) {
      const state = progressState[cat];
      const records = players[current].progress[cat];

      if (state.index === 0) {
        createNewProgressRecord(cat);
      } else {
        state.index--;
      }

      animateSwipe(cat, "left");
      renderProgressPanel(cat);
    }

    function handleSwipeRight(cat) {
      const state = progressState[cat];
      const records = players[current].progress[cat];

      if (state.index < records.length - 1) {
        state.index++;
        animateSwipe(cat, "right");
        renderProgressPanel(cat);
      }
    }
  }

  function animateSwipe(category, direction) {
    const panel = document.getElementById(`progress-${category}`);
    panel.classList.add(`swipe-${direction}`);

    setTimeout(() => {
      panel.classList.remove(`swipe-${direction}`);
    }, 150);
  }

  function createNewProgressRecord(category) {
    const player = players[current];
    const records = player.progress[category];
    const latestRecord = records[0];

    const today = new Date().toISOString().split("T")[0];

    const version = LATEST_CONFIG_VERSION;
    const cfg = RATING_CONFIGS[version][category];

    const newRecord = {
      date: today,
      sessionId: crypto.randomUUID(),
      media: { attachments: [] },
      configVersion: version
    };

    cfg.forEach(item => {
      if (latestRecord && latestRecord[item.field] != null) {
        newRecord[item.field] = latestRecord[item.field];
      } else {
        newRecord[item.field] = 1;
      }
    });

    records.unshift(newRecord);
    progressState[category].index = 0;

    save();
  }

  function renderProgressPanel(category) {
    const player = players[current];
    const records = player.progress[category];
    const index = progressState[category].index;
    const record = records[index];
    const version = record.configVersion || 1;
    const cfg = RATING_CONFIGS[version][category];

    const recordEl = document.getElementById(`${category}Record`);

    if (index === 0) {
      recordEl.classList.add("editable");
      recordEl.classList.remove("readonly");
    } else {
      recordEl.classList.add("readonly");
      recordEl.classList.remove("editable");
    }

    const visualNumber = records.length - index;
    document.getElementById(`${category}RecordIndex`).textContent =
      `Session ${visualNumber} of ${records.length}`;

    document.getElementById(`${category}RecordDate`).textContent =
      formatDate(record.date);

    const ratingGroup = document.querySelector(`#progress-${category} .rating-group-grid`);

    ratingGroup.innerHTML =
      cfg
        .sort((a, b) => a.order - b.order)
        .map(item => `
          <div class="rating-item">
            <div class="rating-label">${item.label}</div>
            <div class="rating-circles" data-field="${item.field}">
              ${Array.from({ length: item.max }, (_, i) => `
                <div class="circle" data-level="${i + 1}"></div>
              `).join("")}
            </div>
          </div>
        `).join("");

    if (index === 0) {
      cfg.forEach(item => {
        const circles = document.querySelectorAll(
          `#progress-${category} .rating-circles[data-field="${item.field}"] .circle`
        );

        circles.forEach(circle => {
          circle.addEventListener("click", () => {
            const level = Number(circle.dataset.level);
            record[item.field] = level;
            renderProgressPanel(category);
            save();
          });
        });
      });
    }

    cfg.forEach(item => {
      const field = item.field;
      const circles = document.querySelectorAll(
        `#progress-${category} .rating-circles[data-field="${field}"] .circle`
      );

      circles.forEach(circle => {
        const level = Number(circle.dataset.level);

        circle.classList.remove("active-blue", "active-green");

        if (index === 0) {
          if (record[field] === level) circle.classList.add("active-blue");
          circle.style.pointerEvents = "auto";
        } else {
          if (record[field] === level) circle.classList.add("active-green");
          circle.style.pointerEvents = "none";
        }
      });
    });

    renderAttachments(category, record);
  }

  function renderAttachments(category, record) {
    if (!record.media) record.media = { attachments: [] };
    if (!record.media.attachments) record.media.attachments = [];

    const container = document.getElementById(`${category}Attachments`);
    container.innerHTML = "";

    const isEditable = progressState[category].index === 0;

    // Only attachments for this category
    const attachments = record.media.attachments.filter(a => a.category === category);
    const count = attachments.length;

    // Paperclip icon
    const icon = document.createElement("img");
    icon.src = "icons/paperclip.svg";
    icon.className = "attachments-icon";

    // Count or "+"
    const countEl = document.createElement("span");
    countEl.className = "attachments-count";

    if (count > 0) {
      countEl.textContent = count;
    } else if (isEditable) {
      countEl.textContent = "+";
    } else {
      container.classList.add("disabled");
    }

    // Evaluation badge logic
    let badgeClass = "eval-none";

    if (count > 0) {
      const evaluated = attachments.filter(a => a.evaluation?.evaluated).length;
      const failed = attachments.filter(a => a.evaluation?.error).length;

      if (evaluated === 0 && failed === 0) badgeClass = "eval-none";
      else if (evaluated === count) badgeClass = "eval-all";
      else if (failed > 0) badgeClass = "eval-some"; // partial failures
      else badgeClass = "eval-some";
    }

    const badge = document.createElement("div");
    badge.className = `eval-session-badge ${badgeClass}`;

    badge.setAttribute("data-tooltip", {
      "eval-none": "No evaluations yet",
      "eval-some": "Some evaluated / some failed",
      "eval-all": "All evaluated"
    }[badgeClass]);

    container.appendChild(icon);
    container.appendChild(countEl);
    container.appendChild(badge);

    container.onclick = () => {
      if (isEditable) openAttachmentPicker(category);
      else openAttachmentViewer(category, progressState[category].index, attachments);
    };
  }
  // function renderAttachments(category, record) {
  //   if (!record.media) record.media = { attachments: [] };
  //   if (!record.media.attachments) record.media.attachments = [];

  //   const container = document.getElementById(`${category}Attachments`);
  //   container.innerHTML = "";

  //   const isEditable = progressState[category].index === 0;
  //   const attachments = record.media.attachments;
  //   const count = attachments.length;

  //   const icon = document.createElement("img");
  //   icon.src = "icons/paperclip.svg";
  //   icon.className = "attachments-icon";

  //   const countEl = document.createElement("span");
  //   countEl.className = "attachments-count";

  //   if (count > 0) {
  //     countEl.textContent = count;
  //   } else if (isEditable) {
  //     countEl.textContent = "+";
  //   } else {
  //     container.classList.add("disabled");
  //   }

  //   let badgeClass = "gemini-none";

  //   if (count > 0) {
  //     const evaluated = attachments.filter(a => a.gemini).length;

  //     if (evaluated === 0) badgeClass = "gemini-none";
  //     else if (evaluated === count) badgeClass = "gemini-all";
  //     else badgeClass = "gemini-some";
  //   }

  //   const badge = document.createElement("div");
  //   badge.className = `gemini-session-badge ${badgeClass}`;

  //   container.appendChild(icon);
  //   container.appendChild(countEl);
  //   container.appendChild(badge);

  //   container.onclick = () => {
  //     if (isEditable) openAttachmentPicker(category);
  //     else openAttachmentViewer(category, progressState[category].index, attachments);
  //   };
  // }

  function openAttachmentPicker(category) {
    if (!progressState[category]) {
      progressState[category] = { index: 0 };
    }
    const modal = document.getElementById("attachmentModal");
    const content = document.getElementById("attachmentModalContent");

    content.innerHTML = `
      <h3>Add Attachment</h3>
      <button id="batchGeminiBtn" class="gemini-batch-btn">Evaluate All</button>
      <button id="addPhotoVideoBtn">Add Photo/Video</button>
      <button id="addNoteBtn">Add Note</button>
      <button id="closeModalBtn">Cancel</button>
    `;

    modal.classList.remove("hidden");

    document.getElementById("closeModalBtn").onclick = () => {
      modal.classList.add("hidden");
    };

    document.getElementById("addPhotoVideoBtn").onclick = () => {
      const input = document.getElementById("nativeVideoInput");
      input.dataset.category = category;   // persist category
      input.value = "";                    // reset so same file can be selected twice
      input.click();

      modal.classList.add("hidden");
    };

    document.getElementById("nativeVideoInput").onchange = e => {
      const file = e.target.files[0];
      if (!file) return;

      const category = e.target.dataset.category;
      handleDirectFileUpload(file, category);
    };

    document.getElementById("addNoteBtn").onclick = () => {
      modal.classList.add("hidden");
      openNoteCreator(category);
    };

    document.getElementById("evaluateBtn").onclick = async () => {
      const btn = document.getElementById("evaluateBtn");
      btn.textContent = "Evaluating‚Ä¶";

      try {
        const result = await evaluateSingleAttachment(attachment, {
          playerId: players[current].id,
          sessionId: record.sessionId,
          category,
          userTier: record.userTier
        });

        attachment.evaluation = normalizeEvaluation(result);
        savePlayer(players[current]);
        renderEvaluationPanel(attachment);

        btn.textContent = "Evaluate Again";
      } catch (err) {
        alert("Evaluation failed.");
        btn.textContent = "Evaluate";
      }
    };

  }

  function openNoteCreator(category) {
    const modal = document.getElementById("attachmentModal");
    const content = document.getElementById("attachmentModalContent");

    content.innerHTML = `
      <h3>Add Note</h3>
      <textarea id="noteText" placeholder="Enter note..." style="width:100%;height:120px;"></textarea>
      <div style="margin-top:12px;">
        <button id="saveNoteBtn">Save Note</button>
        <button id="cancelNoteBtn">Cancel</button>
      </div>
    `;

    modal.classList.remove("hidden");

    document.getElementById("cancelNoteBtn").onclick = () => {
      modal.classList.add("hidden");
    };

    document.getElementById("saveNoteBtn").onclick = () => {
      const text = document.getElementById("noteText").value.trim();
      if (!text) {
        alert("Note cannot be empty.");
        return;
      }

      const attachment = {
        id: crypto.randomUUID(),
        type: "note",
        text,
        timestamp: Date.now(),
        gemini: null
      };

      const record = players[current].progress[category][progressState[category].index];

      if (!record.media) record.media = { attachments: [] };
      if (!record.media.attachments) record.media.attachments = [];

      record.media.attachments.push(attachment);

      savePlayer(players[current]);

      modal.classList.add("hidden");

      renderAttachments(category, record);
    };
  }

  function openAttachmentViewer(category, sessionIndex, attachments) {
    const modal = document.getElementById("attachmentModal");
    const content = document.getElementById("attachmentModalContent");

    let html = `<h3>Attachments</h3><div class="attachment-grid">`;

    attachments.forEach(att => {
      const evaluated = att.evaluation?.evaluated;
      const failed = att.evaluation?.error;

      let badgeClass = "eval-none";
      if (evaluated) badgeClass = "eval-all";
      else if (failed) badgeClass = "eval-some";

      html += `
        <div class="attachment-thumb" data-id="${att.id}">
          ${att.type === "image" ? `<img src="${att.url}" class="thumb-img">` : ""}
          ${att.type === "video" ? `<video src="${att.url}" class="thumb-video"></video>` : ""}
          ${att.type === "note" ? `<div class="note-thumb">${att.text.slice(0,40)}...</div>` : ""}
          <div class="eval-session-badge ${badgeClass}"></div>
        </div>
      `;
    });

    html += `</div><button id="closeModalBtn">Close</button>`;

    content.innerHTML = html;
    modal.classList.remove("hidden");

    document.getElementById("closeModalBtn").onclick = () => {
      modal.classList.add("hidden");
    };

    content.querySelectorAll(".attachment-thumb").forEach(div => {
      div.onclick = () => {
        const id = div.dataset.id;
        const att = attachments.find(a => a.id === id);

        modal.classList.add("hidden");
        openAttachmentViewerSingle(category, sessionIndex, att);
      };
    });
  }

  function openAttachmentViewerSingle(category, sessionIndex, attachment) {
    const modal = document.getElementById("attachmentViewerModal");
    const content = document.getElementById("attachmentViewerContent");

    let previewHTML = "";

    if (attachment.type === "image") {
      previewHTML = `<img src="${attachment.url}" />`;
    } else if (attachment.type === "video") {
      previewHTML = `<video src="${attachment.url}" controls></video>`;
    } else if (attachment.type === "note") {
      previewHTML = `<div class="note-viewer">${attachment.text}</div>`;
    }

    // Evaluation panel (hidden until populated)
    const evaluationPanel = `
      <div id="evaluationPanel" class="evaluation-panel hidden">
        <div class="evaluation-header">
          <span class="evaluation-title">Evaluation</span>
          <span id="evaluationProvider" class="evaluation-provider"></span>
        </div>

        <div id="evaluationScore" class="evaluation-score"></div>
        <div id="evaluationSummary" class="evaluation-summary"></div>
        <ul id="evaluationKeyPoints" class="evaluation-keypoints"></ul>
        <div id="evaluationError" class="evaluation-error hidden"></div>
      </div>
    `;

    content.innerHTML = `
      <h3>Attachment</h3>
      ${previewHTML}

      <div class="attachment-viewer-buttons">
        <button id="deleteAttachmentBtn" style="background:#d9534f;color:white;">Delete</button>
        <button id="evaluateBtn" style="background:#0275d8;color:white;">Evaluate</button>
        <button id="closeAttachmentViewerBtn">Close</button>
      </div>

      ${evaluationPanel}
    `;

    modal.classList.remove("hidden");

    document.getElementById("closeAttachmentViewerBtn").onclick = () => {
      modal.classList.add("hidden");
    };

    document.getElementById("deleteAttachmentBtn").onclick = () => {
      const record = players[current].progress[category][sessionIndex];
      record.media.attachments = record.media.attachments.filter(a => a.id !== attachment.id);

      savePlayer(players[current]);
      modal.classList.add("hidden");
      renderAttachments(category, record);
    };

    // Render existing evaluation if present
    renderEvaluationPanel(attachment);

    // Evaluate button
    document.getElementById("evaluateBtn").onclick = async () => {
      const btn = document.getElementById("evaluateBtn");
      btn.textContent = "Evaluating‚Ä¶";

      try {
        const result = await evaluateSingleAttachment(attachment); // you'll implement this

        attachment.evaluation = {
          evaluated: true,
          provider: result.provider,
          summary: result.summary,
          keyPoints: result.keyPoints,
          score: result.score,
          rawResponse: result.rawResponse
        };

        savePlayer(players[current]);
        renderEvaluationPanel(attachment);

        btn.textContent = "Evaluate Again";
      } catch (err) {
        alert("Evaluation failed.");
        btn.textContent = "Evaluate";
      }
    };
  }

  function renderEvaluationPanel(att) {
    const panel = document.getElementById("evaluationPanel");
    const providerEl = document.getElementById("evaluationProvider");
    const scoreEl = document.getElementById("evaluationScore");
    const summaryEl = document.getElementById("evaluationSummary");
    const keyPointsEl = document.getElementById("evaluationKeyPoints");
    const errorEl = document.getElementById("evaluationError");

    // Reset
    panel.classList.add("hidden");
    errorEl.classList.add("hidden");
    keyPointsEl.innerHTML = "";
    scoreEl.textContent = "";
    summaryEl.textContent = "";
    providerEl.textContent = "";

    if (!att.evaluation) return;

    panel.classList.remove("hidden");

    if (att.evaluation.error) {
      errorEl.textContent = `Evaluation failed: ${att.evaluation.error}`;
      errorEl.classList.remove("hidden");
      return;
    }

    providerEl.textContent = att.evaluation.provider || "";
    scoreEl.textContent = att.evaluation.score != null ? `Score: ${att.evaluation.score}` : "";
    summaryEl.textContent = att.evaluation.summary || "";

    if (Array.isArray(att.evaluation.keyPoints)) {
      att.evaluation.keyPoints.forEach(kp => {
        const li = document.createElement("li");
        li.textContent = kp;
        keyPointsEl.appendChild(li);
      });
    }
  }

  // function openAttachmentViewer(category, sessionIndex, attachments) {
  //   const modal = document.getElementById("attachmentModal");
  //   const content = document.getElementById("attachmentModalContent");

  //   let html = `<h3>Attachments</h3><div class="attachment-grid">`;

  //   attachments.forEach(att => {
  //     const badgeClass = att.gemini ? "gemini-badge" : "gemini-badge pending";

  //     html += `
  //       <div class="attachment-thumb" data-id="${att.id}">
  //         ${att.type === "image" ? `<img src="${att.url}" class="thumb-img">` : ""}
  //         ${att.type === "video" ? `<video src="${att.url}" class="thumb-video"></video>` : ""}
  //         ${att.type === "note" ? `<div class="note-thumb">${att.text.slice(0,40)}...</div>` : ""}
  //         <div class="${badgeClass}"></div>
  //       </div>
  //     `;
  //   });

  //   html += `</div><button id="closeModalBtn">Close</button>`;

  //   content.innerHTML = html;
  //   modal.classList.remove("hidden");

  //   document.getElementById("closeModalBtn").onclick = () => {
  //     modal.classList.add("hidden");
  //   };

  //   content.querySelectorAll(".attachment-thumb").forEach(div => {
  //     div.onclick = () => {
  //       const id = div.dataset.id;
  //       const att = attachments.find(a => a.id === id);

  //       modal.classList.add("hidden");

  //       openAttachmentViewerSingle(category, sessionIndex, att);
  //     };
  //   });
  // }

  // function openAttachmentViewerSingle(category, sessionIndex, attachment) {
  //   const modal = document.getElementById("attachmentViewerModal");
  //   const content = document.getElementById("attachmentViewerContent");

  //   let previewHTML = "";

  //   if (attachment.type === "image") {
  //     previewHTML = `<img src="${attachment.url}" />`;
  //   } else if (attachment.type === "video") {
  //     previewHTML = `<video src="${attachment.url}" controls></video>`;
  //   } else if (attachment.type === "note") {
  //     previewHTML = `<div class="note-viewer">${attachment.text}</div>`;
  //   }

  //   const geminiHTML = attachment.gemini
  //     ? `<div id="geminiResultBox">
  //          <strong>Gemini Evaluation:</strong><br>
  //          ${attachment.gemini.summary || "No summary"}
  //        </div>`
  //     : `<div id="geminiResultBox" style="display:none;"></div>`;

  //   content.innerHTML = `
  //     <h3>Attachment</h3>
  //     ${previewHTML}

  //     <div class="attachment-viewer-buttons">
  //       <button id="deleteAttachmentBtn" style="background:#d9534f;color:white;">Delete</button>
  //       <button id="geminiBtn" style="background:#0275d8;color:white;">Evaluate</button>
  //       <button id="closeAttachmentViewerBtn">Close</button>
  //     </div>

  //     ${geminiHTML}
  //   `;

  //   modal.classList.remove("hidden");

  //   document.getElementById("closeAttachmentViewerBtn").onclick = () => {
  //     modal.classList.add("hidden");
  //   };

  //   document.getElementById("deleteAttachmentBtn").onclick = () => {
  //     const record = players[current].progress[category][sessionIndex];
  //     record.media.attachments = record.media.attachments.filter(a => a.id !== attachment.id);

  //     savePlayer(players[current]);
  //     modal.classList.add("hidden");
  //     renderAttachments(category, record);
  //   };

  //   document.getElementById("geminiBtn").onclick = async () => {
  //     const btn = document.getElementById("geminiBtn");
  //     btn.textContent = "Evaluating...";

  //     const payload = {
  //       playerId: players[current].id,
  //       teamId: currentTeamName,
  //       category,
  //       sessionIndex,
  //       attachmentId: attachment.id,
  //       url: attachment.url
  //     };

  //     try {
  //       const result = await geminiEvaluateSingle(payload);

  //       // Save into attachment metadata
  //       attachment.gemini = result;
  //       savePlayer(players[current]);

  //       const box = document.getElementById("geminiResultBox");
  //       box.style.display = "block";
  //       box.innerHTML = `
  //         <strong>Gemini Evaluation:</strong><br>
  //         ${result.summary || "No summary"}
  //       `;

  //       btn.textContent = "Evaluate Again";
  //     } catch (err) {
  //       alert("Gemini evaluation failed.");
  //       btn.textContent = "Evaluate";
  //     }
  //   };

  // }


  function initCircleListeners() {
    const allCircles = document.querySelectorAll(".rating-circles .circle");

    allCircles.forEach(circle => {
      circle.addEventListener("click", () => {
        const field = circle.parentElement.dataset.field;
        const level = Number(circle.dataset.level);

        const category = getCategoryFromElement(circle);
        const index = progressState[category].index;
        if (index !== 0) return;

        const player = players[current];
        const record = player.progress[category][0];

        record[field] = level;

        save();
        renderProgressPanel(category);
      });
    });
  }

  function getCategoryFromElement(el) {
    const recordEl = el.closest(".progress-record");
    if (!recordEl) return null;
    if (recordEl.id.includes("hitting")) return "hitting";
    if (recordEl.id.includes("fielding")) return "fielding";
    if (recordEl.id.includes("intangibles")) return "intangibles";
    return null;
  }

  function formatDate(iso) {
    const d = new Date(iso);
    return d.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric"
    });
  }

  function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
</script>

<!-- 8. PROFILE PHOTO & INPUT HANDLERS -->
<script data-chunk="profile-photo-and-inputs">
  document.addEventListener("input", e => {
    const el = e.target;
    if (!el.matches("input[data-field], textarea[data-field]")) return;

    const field = el.getAttribute("data-field");
    if (!players[current]) players[current] = {};
    players[current][field] = el.value;
    save();
    loadPlayer();
  });

  document.addEventListener("click", e => {
    const circle = e.target.closest(".circle");
    if (circle) {
      const group = circle.closest(".rating-circles");
      if (group) {
        const field = group.getAttribute("data-field");
        const level = parseInt(circle.getAttribute("data-level"), 10);
        if (!players[current]) players[current] = {};
        players[current][field] = level;
        save();

        group.querySelectorAll(".circle").forEach(c => c.classList.remove("selected"));
        circle.classList.add("selected");
        updateSummary();
      }
    }

    const throwsOption = e.target.closest(".throws-option");
    if (throwsOption) {
      const value = throwsOption.getAttribute("data-throws-value");
      if (!players[current]) players[current] = {};
      players[current].throws = value;
      save();

      document.querySelectorAll(".throws-option").forEach(opt => opt.classList.remove("selected"));
      throwsOption.classList.add("selected");
    }
  });

  document.getElementById("profilePicWrapper").addEventListener("click", () => {
    document.getElementById("photoInput").click();
  });

  document.getElementById("photoInput").addEventListener("change", function () {
    const file = this.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (event) {
      const img = new Image();
      img.onload = function () {
        const canvas = document.createElement("canvas");
        const maxSize = 300;
        let width = img.width;
        let height = img.height;

        if (width > height) {
          if (width > maxSize) {
            height *= maxSize / width;
            width = maxSize;
          }
        } else {
          if (height > maxSize) {
            width *= maxSize / height;
            height = maxSize;
          }
        }

        canvas.width = width;
        canvas.height = height;

        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, width, height);

        const compressedData = canvas.toDataURL("image/jpeg", 0.7);

        players[current].photo = compressedData;
        save();
        loadPlayer();
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  });

  document.getElementById("navPrevPlayer").addEventListener("click", () => {
    changePlayer(-1);
  });

  document.getElementById("navNextPlayer").addEventListener("click", () => {
    changePlayer(1);
  });

  document.getElementById("navPlayerTitle").addEventListener("click", () => {
    openAllPlayersSelector();
  });
</script>

<!-- 9. AI Evaluation Helper -->
<script data-chunk="ai-client">
  //
  // 1. Utility: get all event attachments for a category
  //
  function getEventAttachments(category, record) {
    return (record.media?.attachments || []).filter(
      a => a.category === category && a.type === "video"
    );
  }

  //
  // 2. Core API: batch evaluation
  //
  async function evaluateBatch(events, { playerId, sessionId, category, userTier = "free" }) {
    const res = await fetch(`${API_BASE}/evaluate-media`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        events,
        playerId,
        sessionId,
        category,
        userTier
      })
    });

    const data = await res.json();

    if (!res.ok) {
      throw new Error(data.error || "Evaluation failed");
    }

    return data; // { evaluations, partialFailure, successCount, failureCount }
  }

  //
  // 3. Core API: single-attachment evaluation
  //
  async function evaluateSingleAttachment(attachment, { playerId, sessionId, category, userTier = "free" }) {
    const events = [
      {
        eventIndex: attachment.eventIndex,
        url: attachment.url
      }
    ];

    const result = await evaluateBatch(events, { playerId, sessionId, category, userTier });
    return result.evaluations[0];
  }

  //
  // 4. Normalize evaluation response
  //
  function normalizeEvaluation(ev) {
    if (!ev.success) {
      return {
        evaluated: false,
        provider: null,
        summary: null,
        keyPoints: [],
        score: null,
        rawResponse: null,
        error: ev.error
      };
    }

    return {
      evaluated: true,
      provider: ev.provider,
      summary: ev.summary,
      keyPoints: ev.keyPoints,
      score: ev.score,
      rawResponse: ev.rawResponse,
      error: null
    };
  }

  //
  // 5. Apply evaluations to attachments
  //
  function applyEvaluationsToAttachments(record, category, evaluations) {
    evaluations.forEach(ev => {
      const att = record.media.attachments.find(
        a => a.category === category && a.eventIndex === ev.eventIndex
      );
      if (!att) return;

      att.evaluation = normalizeEvaluation(ev);
    });
  }

  //
  // 6. Evaluate all attachments in a category
  //
  async function evaluateCategoryBatch(record, category, userTier = "free") {
    const events = getEventAttachments(category, record).map(a => ({
      eventIndex: a.eventIndex,
      url: a.url
    }));

    if (events.length === 0) {
      throw new Error("No event clips to evaluate");
    }

    return await evaluateBatch(events, {
      playerId: record.playerId,
      sessionId: record.sessionId,
      category,
      userTier
    });
  }

  //
  // 7. Retry failed evaluations
  //
  async function retryFailedEvaluations(record, category, userTier = "free") {
    const failed = getEventAttachments(category, record).filter(
      a => a.evaluation?.error
    );

    const events = failed.map(a => ({
      eventIndex: a.eventIndex,
      url: a.url
    }));

    if (events.length === 0) return null;

    return await evaluateBatch(events, {
      playerId: record.playerId,
      sessionId: record.sessionId,
      category,
      userTier
    });
  }

  //
  // 8. Status helpers
  //
  function isEvaluated(att) {
    return att.evaluation?.evaluated === true;
  }

  function isFailed(att) {
    return !!att.evaluation?.error;
  }

  function isPending(att) {
    return !att.evaluation;
  }
</script>

<!-- 10. DRIVER CODE (LAST) -->
<script data-chunk="driver-code">
  normalizeAllPlayers();
  renderTeamList();
  initCircleListeners();
  initProgressSwipeListeners();
  buildPlayersTable();
</script>

</body>
</html>